"use strict";
// Copyright 2020 Google Inc. Use of this source code is governed by an
// MIT-style license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT.
Object.defineProperty(exports, "__esModule", { value: true });
exports.cleanDir = exports.link = exports.fetchRepo = exports.BUILD_PATH = void 0;
const fs_1 = require("fs");
const p = require("path");
const shell = require("shelljs");
shell.config.fatal = true;
// Directory that holds source files.
exports.BUILD_PATH = 'build';
// Clones `repo` into `outPath`, then checks out the given Git `ref`.
function fetchRepo(options) {
    if (!(0, fs_1.existsSync)(p.join(options.outPath, options.repo))) {
        console.log(`Cloning ${options.repo} into ${options.outPath}.`);
        shell.exec(`git clone \
      --depth=1 \
      https://github.com/sass/${options.repo} \
      ${p.join(options.outPath, options.repo)}`, { silent: true });
    }
    const version = options.ref === 'main' ? 'latest update' : `commit ${options.ref}`;
    console.log(`Fetching ${version} for ${options.repo}.`);
    shell.exec(`git fetch --depth=1 origin ${options.ref} && git reset --hard FETCH_HEAD`, {
        silent: true,
        cwd: p.join(options.outPath, options.repo),
    });
}
exports.fetchRepo = fetchRepo;
// Links or copies the contents of `source` into `destination`.
async function link(source, destination) {
    await cleanDir(destination);
    if (process.platform === 'win32') {
        console.log(`Copying ${source} into ${destination}.`);
        shell.cp('-R', source, destination);
    }
    else {
        console.log(`Linking ${source} into ${destination}.`);
        // Symlinking doesn't play nice with Jasmine's test globbing on Windows.
        await fs_1.promises.symlink(p.resolve(source), destination);
    }
}
exports.link = link;
// Ensures that `dir` does not exist, but its parent directory does.
async function cleanDir(dir) {
    await fs_1.promises.mkdir(p.dirname(dir), { recursive: true });
    try {
        await fs_1.promises.rm(dir, { force: true, recursive: true });
    }
    catch (_) {
        // If dir doesn't exist yet, that's fine.
    }
}
exports.cleanDir = cleanDir;
//# sourceMappingURL=utils.js.map