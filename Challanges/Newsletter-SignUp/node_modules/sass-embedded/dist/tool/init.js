"use strict";
// Copyright 2020 Google Inc. Use of this source code is governed by an
// MIT-style license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT.
Object.defineProperty(exports, "__esModule", { value: true });
const yargs_1 = require("yargs");
const get_embedded_compiler_1 = require("./get-embedded-compiler");
const get_embedded_protocol_1 = require("./get-embedded-protocol");
const get_js_api_1 = require("./get-js-api");
const argv = (0, yargs_1.default)(process.argv.slice(2))
    .option('compiler-path', {
    type: 'string',
    description: 'Build the Embedded Dart Sass binary from the source at this path.',
})
    .option('compiler-ref', {
    type: 'string',
    description: 'Build the Embedded Dart Sass binary from this Git ref.',
})
    .option('skip-compiler', {
    type: 'boolean',
    description: "Don't Embedded Dart Sass at all.",
})
    .option('protocol-path', {
    type: 'string',
    description: 'Build the Embedded Protocol from the source at this path.',
})
    .option('protocol-ref', {
    type: 'string',
    description: 'Build the Embedded Protocol from this Git ref.',
})
    .option('api-path', {
    type: 'string',
    description: 'Use the JS API definitions from the source at this path.',
})
    .option('api-ref', {
    type: 'string',
    description: 'Build the JS API definitions from this Git ref.',
})
    .conflicts({
    'compiler-path': ['compiler-ref', 'skip-compiler'],
    'compiler-ref': ['skip-compiler'],
    'protocol-path': ['protocol-ref'],
    'api-path': 'api-ref',
})
    .parseSync();
(async () => {
    try {
        const outPath = 'lib/src/vendor';
        if (argv['protocol-ref']) {
            await (0, get_embedded_protocol_1.getEmbeddedProtocol)(outPath, {
                ref: argv['protocol-ref'],
            });
        }
        else if (argv['protocol-path']) {
            await (0, get_embedded_protocol_1.getEmbeddedProtocol)(outPath, {
                path: argv['protocol-path'],
            });
        }
        else {
            await (0, get_embedded_protocol_1.getEmbeddedProtocol)(outPath);
        }
        if (!argv['skip-compiler']) {
            if (argv['compiler-ref']) {
                await (0, get_embedded_compiler_1.getEmbeddedCompiler)(outPath, {
                    ref: argv['compiler-ref'],
                });
            }
            else if (argv['compiler-path']) {
                await (0, get_embedded_compiler_1.getEmbeddedCompiler)(outPath, {
                    path: argv['compiler-path'],
                });
            }
            else {
                await (0, get_embedded_compiler_1.getEmbeddedCompiler)(outPath);
            }
        }
        if (argv['api-ref']) {
            await (0, get_js_api_1.getJSApi)(outPath, {
                ref: argv['api-ref'],
            });
        }
        else if (argv['api-path']) {
            await (0, get_js_api_1.getJSApi)(outPath, {
                path: argv['api-path'],
            });
        }
        else {
            await (0, get_js_api_1.getJSApi)(outPath);
        }
    }
    catch (error) {
        console.error(error);
        process.exitCode = 1;
    }
})();
//# sourceMappingURL=init.js.map